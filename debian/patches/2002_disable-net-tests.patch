Description: Disable network tests
Author: Ximin Luo <infinity0@debian.org>
Forwarded: TODO
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/tests/testsuite/build_auth.rs
+++ b/tests/testsuite/build_auth.rs
@@ -1,269 +1,269 @@
-use std;
-use std::collections::HashSet;
-use std::io::prelude::*;
-use std::net::TcpListener;
-use std::thread;
-
-use git2;
-use bufstream::BufStream;
-use cargotest::support::paths;
-use cargotest::support::{execs, project};
-use hamcrest::assert_that;
+// use std;
+// use std::collections::HashSet;
+// use std::io::prelude::*;
+// use std::net::TcpListener;
+// use std::thread;
+
+// use git2;
+// use bufstream::BufStream;
+// use cargotest::support::paths;
+// use cargotest::support::{execs, project};
+// use hamcrest::assert_that;
 
 // Test that HTTP auth is offered from `credential.helper`
-#[test]
-fn http_auth_offered() {
-    let server = TcpListener::bind("127.0.0.1:0").unwrap();
-    let addr = server.local_addr().unwrap();
-
-    fn headers(rdr: &mut BufRead) -> HashSet<String> {
-        let valid = ["GET", "Authorization", "Accept", "User-Agent"];
-        rdr.lines()
-            .map(|s| s.unwrap())
-            .take_while(|s| s.len() > 2)
-            .map(|s| s.trim().to_string())
-            .filter(|s| valid.iter().any(|prefix| s.starts_with(*prefix)))
-            .collect()
-    }
-
-    let t = thread::spawn(move || {
-        let mut conn = BufStream::new(server.accept().unwrap().0);
-        let req = headers(&mut conn);
-        let user_agent = "User-Agent: git/2.0 (libgit2 0.27.0)";
-        conn.write_all(
-            b"\
-            HTTP/1.1 401 Unauthorized\r\n\
-            WWW-Authenticate: Basic realm=\"wheee\"\r\n
-            \r\n\
-        ",
-        ).unwrap();
-        assert_eq!(
-            req,
-            vec![
-                "GET /foo/bar/info/refs?service=git-upload-pack HTTP/1.1",
-                "Accept: */*",
-                user_agent,
-            ].into_iter()
-                .map(|s| s.to_string())
-                .collect()
-        );
-        drop(conn);
-
-        let mut conn = BufStream::new(server.accept().unwrap().0);
-        let req = headers(&mut conn);
-        conn.write_all(
-            b"\
-            HTTP/1.1 401 Unauthorized\r\n\
-            WWW-Authenticate: Basic realm=\"wheee\"\r\n
-            \r\n\
-        ",
-        ).unwrap();
-        assert_eq!(
-            req,
-            vec![
-                "GET /foo/bar/info/refs?service=git-upload-pack HTTP/1.1",
-                "Authorization: Basic Zm9vOmJhcg==",
-                "Accept: */*",
-                user_agent,
-            ].into_iter()
-                .map(|s| s.to_string())
-                .collect()
-        );
-    });
-
-    let script = project("script")
-        .file(
-            "Cargo.toml",
-            r#"
-            [project]
-            name = "script"
-            version = "0.0.1"
-            authors = []
-        "#,
-        )
-        .file(
-            "src/main.rs",
-            r#"
-            fn main() {
-                println!("username=foo");
-                println!("password=bar");
-            }
-        "#,
-        )
-        .build();
-
-    assert_that(script.cargo("build").arg("-v"), execs().with_status(0));
-    let script = script.bin("script");
-
-    let config = paths::home().join(".gitconfig");
-    let mut config = git2::Config::open(&config).unwrap();
-    config
-        .set_str("credential.helper", &script.display().to_string())
-        .unwrap();
-
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            &format!(
-                r#"
-            [project]
-            name = "foo"
-            version = "0.0.1"
-            authors = []
-
-            [dependencies.bar]
-            git = "http://127.0.0.1:{}/foo/bar"
-        "#,
-                addr.port()
-            ),
-        )
-        .file("src/main.rs", "")
-        .file(
-            ".cargo/config",
-            "\
-        [net]
-        retry = 0
-        ",
-        )
-        .build();
-
-    // This is a "contains" check because the last error differs by platform,
-    // may span multiple lines, and isn't relevant to this test.
-    assert_that(
-        p.cargo("build"),
-        execs().with_status(101).with_stderr_contains(&format!(
-            "\
-[UPDATING] git repository `http://{addr}/foo/bar`
-[ERROR] failed to load source for a dependency on `bar`
-
-Caused by:
-  Unable to update http://{addr}/foo/bar
-
-Caused by:
-  failed to clone into: [..]
-
-Caused by:
-  failed to authenticate when downloading repository
-attempted to find username/password via `credential.helper`, but [..]
-
-Caused by:
-",
-            addr = addr
-        )),
-    );
-
-    t.join().ok().unwrap();
-}
-
-// Boy, sure would be nice to have a TLS implementation in rust!
-#[test]
-fn https_something_happens() {
-    let server = TcpListener::bind("127.0.0.1:0").unwrap();
-    let addr = server.local_addr().unwrap();
-    let t = thread::spawn(move || {
-        let mut conn = server.accept().unwrap().0;
-        drop(conn.write(b"1234"));
-        drop(conn.shutdown(std::net::Shutdown::Write));
-        drop(conn.read(&mut [0; 16]));
-    });
-
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            &format!(
-                r#"
-            [project]
-            name = "foo"
-            version = "0.0.1"
-            authors = []
-
-            [dependencies.bar]
-            git = "https://127.0.0.1:{}/foo/bar"
-        "#,
-                addr.port()
-            ),
-        )
-        .file("src/main.rs", "")
-        .file(
-            ".cargo/config",
-            "\
-        [net]
-        retry = 0
-        ",
-        )
-        .build();
-
-    assert_that(
-        p.cargo("build").arg("-v"),
-        execs()
-            .with_status(101)
-            .with_stderr_contains(&format!(
-                "[UPDATING] git repository `https://{addr}/foo/bar`",
-                addr = addr
-            ))
-            .with_stderr_contains(&format!(
-                "\
-Caused by:
-  {errmsg}
-",
-                errmsg = if cfg!(windows) {
-                    "[..]failed to send request: [..]"
-                } else if cfg!(target_os = "macos") {
-                    // OSX is difficult to tests as some builds may use
-                    // Security.framework and others may use OpenSSL. In that case let's
-                    // just not verify the error message here.
-                    "[..]"
-                } else {
-                    "[..]SSL error: [..]"
-                }
-            )),
-    );
+//#[test]
+// fn http_auth_offered() {
+//     let server = TcpListener::bind("127.0.0.1:0").unwrap();
+//     let addr = server.local_addr().unwrap();
+
+//     fn headers(rdr: &mut BufRead) -> HashSet<String> {
+//         let valid = ["GET", "Authorization", "Accept", "User-Agent"];
+//         rdr.lines()
+//             .map(|s| s.unwrap())
+//             .take_while(|s| s.len() > 2)
+//             .map(|s| s.trim().to_string())
+//             .filter(|s| valid.iter().any(|prefix| s.starts_with(*prefix)))
+//             .collect()
+//     }
+
+//     let t = thread::spawn(move || {
+//         let mut conn = BufStream::new(server.accept().unwrap().0);
+//         let req = headers(&mut conn);
+//         let user_agent = "User-Agent: git/2.0 (libgit2 0.27.0)";
+//         conn.write_all(
+//             b"\
+//             HTTP/1.1 401 Unauthorized\r\n\
+//             WWW-Authenticate: Basic realm=\"wheee\"\r\n
+//             \r\n\
+//         ",
+//         ).unwrap();
+//         assert_eq!(
+//             req,
+//             vec![
+//                 "GET /foo/bar/info/refs?service=git-upload-pack HTTP/1.1",
+//                 "Accept: */*",
+//                 user_agent,
+//             ].into_iter()
+//                 .map(|s| s.to_string())
+//                 .collect()
+//         );
+//         drop(conn);
+
+//         let mut conn = BufStream::new(server.accept().unwrap().0);
+//         let req = headers(&mut conn);
+//         conn.write_all(
+//             b"\
+//             HTTP/1.1 401 Unauthorized\r\n\
+//             WWW-Authenticate: Basic realm=\"wheee\"\r\n
+//             \r\n\
+//         ",
+//         ).unwrap();
+//         assert_eq!(
+//             req,
+//             vec![
+//                 "GET /foo/bar/info/refs?service=git-upload-pack HTTP/1.1",
+//                 "Authorization: Basic Zm9vOmJhcg==",
+//                 "Accept: */*",
+//                 user_agent,
+//             ].into_iter()
+//                 .map(|s| s.to_string())
+//                 .collect()
+//         );
+//     });
+
+//     let script = project("script")
+//         .file(
+//             "Cargo.toml",
+//             r#"
+//             [project]
+//             name = "script"
+//             version = "0.0.1"
+//             authors = []
+//         "#,
+//         )
+//         .file(
+//             "src/main.rs",
+//             r#"
+//             fn main() {
+//                 println!("username=foo");
+//                 println!("password=bar");
+//             }
+//         "#,
+//         )
+//         .build();
+
+//     assert_that(script.cargo("build").arg("-v"), execs().with_status(0));
+//     let script = script.bin("script");
+
+//     let config = paths::home().join(".gitconfig");
+//     let mut config = git2::Config::open(&config).unwrap();
+//     config
+//         .set_str("credential.helper", &script.display().to_string())
+//         .unwrap();
+
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             &format!(
+//                 r#"
+//             [project]
+//             name = "foo"
+//             version = "0.0.1"
+//             authors = []
+
+//             [dependencies.bar]
+//             git = "http://127.0.0.1:{}/foo/bar"
+//         "#,
+//                 addr.port()
+//             ),
+//         )
+//         .file("src/main.rs", "")
+//         .file(
+//             ".cargo/config",
+//             "\
+//         [net]
+//         retry = 0
+//         ",
+//         )
+//         .build();
+
+//     // This is a "contains" check because the last error differs by platform,
+//     // may span multiple lines, and isn't relevant to this test.
+//     assert_that(
+//         p.cargo("build"),
+//         execs().with_status(101).with_stderr_contains(&format!(
+//             "\
+// [UPDATING] git repository `http://{addr}/foo/bar`
+// [ERROR] failed to load source for a dependency on `bar`
+
+// Caused by:
+//   Unable to update http://{addr}/foo/bar
+
+// Caused by:
+//   failed to clone into: [..]
+
+// Caused by:
+//   failed to authenticate when downloading repository
+// attempted to find username/password via `credential.helper`, but [..]
+
+// Caused by:
+// ",
+//             addr = addr
+//         )),
+//     );
+
+//     t.join().ok().unwrap();
+// }
+
+// // Boy, sure would be nice to have a TLS implementation in rust!
+// //#[test]
+// fn https_something_happens() {
+//     let server = TcpListener::bind("127.0.0.1:0").unwrap();
+//     let addr = server.local_addr().unwrap();
+//     let t = thread::spawn(move || {
+//         let mut conn = server.accept().unwrap().0;
+//         drop(conn.write(b"1234"));
+//         drop(conn.shutdown(std::net::Shutdown::Write));
+//         drop(conn.read(&mut [0; 16]));
+//     });
+
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             &format!(
+//                 r#"
+//             [project]
+//             name = "foo"
+//             version = "0.0.1"
+//             authors = []
+
+//             [dependencies.bar]
+//             git = "https://127.0.0.1:{}/foo/bar"
+//         "#,
+//                 addr.port()
+//             ),
+//         )
+//         .file("src/main.rs", "")
+//         .file(
+//             ".cargo/config",
+//             "\
+//         [net]
+//         retry = 0
+//         ",
+//         )
+//         .build();
+
+//     assert_that(
+//         p.cargo("build").arg("-v"),
+//         execs()
+//             .with_status(101)
+//             .with_stderr_contains(&format!(
+//                 "[UPDATING] git repository `https://{addr}/foo/bar`",
+//                 addr = addr
+//             ))
+//             .with_stderr_contains(&format!(
+//                 "\
+// Caused by:
+//   {errmsg}
+// ",
+//                 errmsg = if cfg!(windows) {
+//                     "[..]failed to send request: [..]"
+//                 } else if cfg!(target_os = "macos") {
+//                     // OSX is difficult to tests as some builds may use
+//                     // Security.framework and others may use OpenSSL. In that case let's
+//                     // just not verify the error message here.
+//                     "[..]"
+//                 } else {
+//                     "[..]SSL error: [..]"
+//                 }
+//             )),
+//     );
 
-    t.join().ok().unwrap();
-}
+//     t.join().ok().unwrap();
+// }
 
 // Boy, sure would be nice to have an SSH implementation in rust!
-#[test]
-fn ssh_something_happens() {
-    let server = TcpListener::bind("127.0.0.1:0").unwrap();
-    let addr = server.local_addr().unwrap();
-    let t = thread::spawn(move || {
-        drop(server.accept().unwrap());
-    });
-
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            &format!(
-                r#"
-            [project]
-            name = "foo"
-            version = "0.0.1"
-            authors = []
-
-            [dependencies.bar]
-            git = "ssh://127.0.0.1:{}/foo/bar"
-        "#,
-                addr.port()
-            ),
-        )
-        .file("src/main.rs", "")
-        .build();
-
-    assert_that(
-        p.cargo("build").arg("-v"),
-        execs()
-            .with_status(101)
-            .with_stderr_contains(&format!(
-                "[UPDATING] git repository `ssh://{addr}/foo/bar`",
-                addr = addr
-            ))
-            .with_stderr_contains(
-                "\
-Caused by:
-  [..]failed to start SSH session: Failed getting banner[..]
-",
-            ),
-    );
-    t.join().ok().unwrap();
-}
+//#[test]
+// fn ssh_something_happens() {
+//     let server = TcpListener::bind("127.0.0.1:0").unwrap();
+//     let addr = server.local_addr().unwrap();
+//     let t = thread::spawn(move || {
+//         drop(server.accept().unwrap());
+//     });
+
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             &format!(
+//                 r#"
+//             [project]
+//             name = "foo"
+//             version = "0.0.1"
+//             authors = []
+
+//             [dependencies.bar]
+//             git = "ssh://127.0.0.1:{}/foo/bar"
+//         "#,
+//                 addr.port()
+//             ),
+//         )
+//         .file("src/main.rs", "")
+//         .build();
+
+//     assert_that(
+//         p.cargo("build").arg("-v"),
+//         execs()
+//             .with_status(101)
+//             .with_stderr_contains(&format!(
+//                 "[UPDATING] git repository `ssh://{addr}/foo/bar`",
+//                 addr = addr
+//             ))
+//             .with_stderr_contains(
+//                 "\
+// Caused by:
+//   [..]failed to start SSH session: Failed getting banner[..]
+// ",
+//             ),
+//     );
+//     t.join().ok().unwrap();
+// }
--- a/tests/testsuite/net_config.rs
+++ b/tests/testsuite/net_config.rs
@@ -1,75 +1,75 @@
-use cargotest::support::{execs, project};
-use hamcrest::assert_that;
+// use cargotest::support::{execs, project};
+// use hamcrest::assert_that;
 
-#[test]
-fn net_retry_loads_from_config() {
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            r#"
-            [project]
-            name = "foo"
-            version = "0.0.1"
-            authors = []
-
-            [dependencies.bar]
-            git = "https://127.0.0.1:11/foo/bar"
-        "#,
-        )
-        .file("src/main.rs", "")
-        .file(
-            ".cargo/config",
-            r#"
-        [net]
-        retry=1
-        [http]
-        timeout=1
-         "#,
-        )
-        .build();
-
-    assert_that(
-        p.cargo("build").arg("-v"),
-        execs().with_status(101).with_stderr_contains(
-            "[WARNING] spurious network error \
-             (1 tries remaining): [..]",
-        ),
-    );
-}
-
-#[test]
-fn net_retry_git_outputs_warning() {
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            r#"
-            [project]
-            name = "foo"
-            version = "0.0.1"
-            authors = []
-
-            [dependencies.bar]
-            git = "https://127.0.0.1:11/foo/bar"
-        "#,
-        )
-        .file(
-            ".cargo/config",
-            r#"
-        [http]
-        timeout=1
-         "#,
-        )
-        .file("src/main.rs", "")
-        .build();
-
-    assert_that(
-        p.cargo("build").arg("-v").arg("-j").arg("1"),
-        execs()
-            .with_status(101)
-            .with_stderr_contains(
-                "[WARNING] spurious network error \
-                 (2 tries remaining): [..]",
-            )
-            .with_stderr_contains("[WARNING] spurious network error (1 tries remaining): [..]"),
-    );
-}
+//#[test]
+// fn net_retry_loads_from_config() {
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             r#"
+//             [project]
+//             name = "foo"
+//             version = "0.0.1"
+//             authors = []
+
+//             [dependencies.bar]
+//             git = "https://127.0.0.1:11/foo/bar"
+//         "#,
+//         )
+//         .file("src/main.rs", "")
+//         .file(
+//             ".cargo/config",
+//             r#"
+//         [net]
+//         retry=1
+//         [http]
+//         timeout=1
+//          "#,
+//         )
+//         .build();
+
+//     assert_that(
+//         p.cargo("build").arg("-v"),
+//         execs().with_status(101).with_stderr_contains(
+//             "[WARNING] spurious network error \
+//              (1 tries remaining): [..]",
+//         ),
+//     );
+// }
+
+//#[test]
+// fn net_retry_git_outputs_warning() {
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             r#"
+//             [project]
+//             name = "foo"
+//             version = "0.0.1"
+//             authors = []
+
+//             [dependencies.bar]
+//             git = "https://127.0.0.1:11/foo/bar"
+//         "#,
+//         )
+//         .file(
+//             ".cargo/config",
+//             r#"
+//         [http]
+//         timeout=1
+//          "#,
+//         )
+//         .file("src/main.rs", "")
+//         .build();
+
+//     assert_that(
+//         p.cargo("build").arg("-v").arg("-j").arg("1"),
+//         execs()
+//             .with_status(101)
+//             .with_stderr_contains(
+//                 "[WARNING] spurious network error \
+//                  (2 tries remaining): [..]",
+//             )
+//             .with_stderr_contains("[WARNING] spurious network error (1 tries remaining): [..]"),
+//     );
+// }
--- a/tests/testsuite/test.rs
+++ b/tests/testsuite/test.rs
@@ -3093,114 +3093,114 @@
     );
 }
 
-#[test]
-fn pass_correct_cfgs_flags_to_rustdoc() {
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            r#"
-            [package]
-            name = "foo"
-            version = "0.1.0"
-            authors = []
-
-            [features]
-            default = ["feature_a/default"]
-            nightly = ["feature_a/nightly"]
-
-            [dependencies.feature_a]
-            path = "libs/feature_a"
-            default-features = false
-        "#,
-        )
-        .file(
-            "src/lib.rs",
-            r#"
-            #[cfg(test)]
-            mod tests {
-                #[test]
-                fn it_works() {
-                  assert!(true);
-                }
-            }
-        "#,
-        )
-        .file(
-            "libs/feature_a/Cargo.toml",
-            r#"
-            [package]
-            name = "feature_a"
-            version = "0.1.0"
-            authors = []
-
-            [features]
-            default = ["mock_serde_codegen"]
-            nightly = ["mock_serde_derive"]
-
-            [dependencies]
-            mock_serde_derive = { path = "../mock_serde_derive", optional = true }
-
-            [build-dependencies]
-            mock_serde_codegen = { path = "../mock_serde_codegen", optional = true }
-        "#,
-        )
-        .file(
-            "libs/feature_a/src/lib.rs",
-            r#"
-            #[cfg(feature = "mock_serde_derive")]
-            const MSG: &'static str = "This is safe";
-
-            #[cfg(feature = "mock_serde_codegen")]
-            const MSG: &'static str = "This is risky";
-
-            pub fn get() -> &'static str {
-                MSG
-            }
-        "#,
-        )
-        .file(
-            "libs/mock_serde_derive/Cargo.toml",
-            r#"
-            [package]
-            name = "mock_serde_derive"
-            version = "0.1.0"
-            authors = []
-        "#,
-        )
-        .file("libs/mock_serde_derive/src/lib.rs", "")
-        .file(
-            "libs/mock_serde_codegen/Cargo.toml",
-            r#"
-                [package]
-                name = "mock_serde_codegen"
-                version = "0.1.0"
-                authors = []
-            "#,
-        )
-        .file("libs/mock_serde_codegen/src/lib.rs", "");
-    let p = p.build();
-
-    assert_that(
-        p.cargo("test")
-            .arg("--package")
-            .arg("feature_a")
-            .arg("--verbose"),
-        execs().with_status(0).with_stderr_contains(
-            "\
-[DOCTEST] feature_a
-[RUNNING] `rustdoc --test [..]mock_serde_codegen[..]`",
-        ),
-    );
-
-    assert_that(
-        p.cargo("test").arg("--verbose"),
-        execs().with_status(0).with_stderr_contains(
-            "\
-[DOCTEST] foo
-[RUNNING] `rustdoc --test [..]feature_a[..]`",
-        ),
-    );
-}
+//#[test]
+// fn pass_correct_cfgs_flags_to_rustdoc() {
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             r#"
+//             [package]
+//             name = "foo"
+//             version = "0.1.0"
+//             authors = []
+
+//             [features]
+//             default = ["feature_a/default"]
+//             nightly = ["feature_a/nightly"]
+
+//             [dependencies.feature_a]
+//             path = "libs/feature_a"
+//             default-features = false
+//         "#,
+//         )
+//         .file(
+//             "src/lib.rs",
+//             r#"
+//             #[cfg(test)]
+//             mod tests {
+//                 #[test]
+//                 fn it_works() {
+//                   assert!(true);
+//                 }
+//             }
+//         "#,
+//         )
+//         .file(
+//             "libs/feature_a/Cargo.toml",
+//             r#"
+//             [package]
+//             name = "feature_a"
+//             version = "0.1.0"
+//             authors = []
+
+//             [features]
+//             default = ["mock_serde_codegen"]
+//             nightly = ["mock_serde_derive"]
+
+//             [dependencies]
+//             mock_serde_derive = { path = "../mock_serde_derive", optional = true }
+
+//             [build-dependencies]
+//             mock_serde_codegen = { path = "../mock_serde_codegen", optional = true }
+//         "#,
+//         )
+//         .file(
+//             "libs/feature_a/src/lib.rs",
+//             r#"
+//             #[cfg(feature = "mock_serde_derive")]
+//             const MSG: &'static str = "This is safe";
+
+//             #[cfg(feature = "mock_serde_codegen")]
+//             const MSG: &'static str = "This is risky";
+
+//             pub fn get() -> &'static str {
+//                 MSG
+//             }
+//         "#,
+//         )
+//         .file(
+//             "libs/mock_serde_derive/Cargo.toml",
+//             r#"
+//             [package]
+//             name = "mock_serde_derive"
+//             version = "0.1.0"
+//             authors = []
+//         "#,
+//         )
+//         .file("libs/mock_serde_derive/src/lib.rs", "")
+//         .file(
+//             "libs/mock_serde_codegen/Cargo.toml",
+//             r#"
+//                 [package]
+//                 name = "mock_serde_codegen"
+//                 version = "0.1.0"
+//                 authors = []
+//             "#,
+//         )
+//         .file("libs/mock_serde_codegen/src/lib.rs", "");
+//     let p = p.build();
+
+//     assert_that(
+//         p.cargo("test")
+//             .arg("--package")
+//             .arg("feature_a")
+//             .arg("--verbose"),
+//         execs().with_status(0).with_stderr_contains(
+//             "\
+// [DOCTEST] feature_a
+// [RUNNING] `rustdoc --test [..]mock_serde_codegen[..]`",
+//         ),
+//     );
+
+//     assert_that(
+//         p.cargo("test").arg("--verbose"),
+//         execs().with_status(0).with_stderr_contains(
+//             "\
+// [DOCTEST] foo
+// [RUNNING] `rustdoc --test [..]feature_a[..]`",
+//         ),
+//     );
+// }
 
 #[test]
 fn test_release_ignore_panic() {
--- a/tests/testsuite/generate_lockfile.rs
+++ b/tests/testsuite/generate_lockfile.rs
@@ -1,9 +1,9 @@
 use std::fs::{self, File};
 use std::io::prelude::*;
 
-use cargotest::support::registry::Package;
+// use cargotest::support::registry::Package;
 use cargotest::support::{execs, paths, project, ProjectBuilder};
-use cargotest::ChannelChanger;
+// use cargotest::ChannelChanger;
 use hamcrest::{assert_that, existing_file, is_not};
 
 #[test]
@@ -90,38 +90,37 @@
     assert_eq!(lock1, lock4);
 }
 
-#[test]
-fn no_index_update() {
-    Package::new("serde", "1.0.0").publish();
-
-    let p = project("foo")
-        .file(
-            "Cargo.toml",
-            r#"
-            [package]
-            name = "foo"
-            authors = []
-            version = "0.0.1"
-
-            [dependencies]
-            serde = "1.0"
-        "#,
-        )
-        .file("src/main.rs", "fn main() {}")
-        .build();
+// fn no_index_update() {
+//     Package::new("serde", "1.0.0").publish();
 
-    assert_that(
-        p.cargo("generate-lockfile"),
-        execs().with_stderr("[UPDATING] registry `[..]`"),
-    );
-
-    assert_that(
-        p.cargo("generate-lockfile")
-            .masquerade_as_nightly_cargo()
-            .arg("-Zno-index-update"),
-        execs().with_status(0).with_stdout("").with_stderr(""),
-    );
-}
+//     let p = project("foo")
+//         .file(
+//             "Cargo.toml",
+//             r#"
+//             [package]
+//             name = "foo"
+//             authors = []
+//             version = "0.0.1"
+
+//             [dependencies]
+//             serde = "1.0"
+//         "#,
+//         )
+//         .file("src/main.rs", "fn main() {}")
+//         .build();
+
+//     assert_that(
+//         p.cargo("generate-lockfile"),
+//         execs().with_stderr("[UPDATING] registry `[..]`"),
+//     );
+
+//     assert_that(
+//         p.cargo("generate-lockfile")
+//             .masquerade_as_nightly_cargo()
+//             .arg("-Zno-index-update"),
+//         execs().with_status(0).with_stdout("").with_stderr(""),
+//     );
+// }
 
 #[test]
 fn preserve_metadata() {
